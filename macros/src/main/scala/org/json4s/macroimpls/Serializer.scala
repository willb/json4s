package org.json4s.macroimpls

import language.experimental.macros
import scala.reflect.macros.Context

import org.json4s.{JsonWriter,JValue}
import macrohelpers._


// Intended to be the serialization side of the class builder
object Serializer {
  
  type Writer = JsonWriter[_]

  // Makes the code generated by the macros significantly less cumbersome
  private[this] class WriterStack(var current:Writer) {
    def startArray() = {
      current = current.startArray()
      current
    }
    def endArray() = {
      current = current.endArray()
      current
    }
    def startObject() = {
      current = current.startObject()
      current
    }
    def endObject() = {
      current = current.endObject()
      current
    }
    def primative(value:Any) = { 
      current = value match {
        case a:Int        => current.int(a)
        case a:String     => current.string(a)
        case a:Float      => current.float(a)
        case a:Double     => current.double(a)
        case a:Boolean    => current.boolean(a)
        case a:Long       => current.long(a)
        case a:Byte       => current.byte(a)
        case a:BigInt     => current.bigInt(a)
        case a:Short      => current.short(a)
        case a:BigDecimal => current.bigDecimal(a)
      }
      current
    }
    def startField(name: String) = {
      current = current.startField(name)
      current
    }
    def addJValue(jv: JValue) = {
      current = current.addJValue(jv)
      current
    }
    def result = current.result
  }

  def serialize[U](obj:U, name:String, writer: Writer) = macro impl[U]
  def impl[U:c.WeakTypeTag](c: Context)(obj: c.Expr[U], name: c.Expr[String], writer: c.Expr[Writer]):c.Expr[Unit] = {
                      
    import c.universe._
    val helpers = new macrohelpers.MacroHelpers[c.type](c)
    import helpers._
    
    // Will help manage the JsonWriters for us instead of having to
    // keep track as we go down the tree
    val Block(writerStackDef::Nil,_) = reify{
      val writerStack = new WriterStack(writer.splice)
    }.tree
    val writerStack = c.Expr[WriterStack](Ident("writerStack"))
    
    val primativeTypes = typeOf[Int]::typeOf[String]::
                          typeOf[Float]::typeOf[Double]::
                          typeOf[Boolean]::typeOf[Long]::
                          typeOf[Byte]::typeOf[BigInt]::
                          typeOf[Short]::typeOf[BigDecimal]::Nil
    
    
    // Assumes that you are already in an object or list
    def dumpObject(tpe:Type,path:Tree,name:c.Expr[String],isList:Boolean=false):c.Tree = {
      
      val startFieldExpr = if(isList) {
        reify{}
      } else reify{writerStack.splice.startField(name.splice)}
      
      if(primativeTypes.exists(_ =:= tpe)) { // Must be primative
        reify{
          startFieldExpr.splice
          writerStack.splice.primative(c.Expr(path).splice)
        }.tree
      } 
      // Handle the lists
      else if(tpe <:< typeOf[scala.collection.Seq[Any]]) {
        val TypeRef(_,sym:Symbol,pTpe::Nil) = tpe
        reify{
          startFieldExpr.splice
          writerStack.splice.startArray()
          c.Expr[scala.collection.Seq[Any]](path).splice.foreach { i =>
            c.Expr(dumpObject(pTpe,Ident("i"),LIT(""),isList=true)).splice
          }
          writerStack.splice.endArray()
        }.tree
      } 
      
      else if(tpe <:< typeOf[scala.collection.GenMap[Any,Any]].erasure) {
        val TypeRef(_,_,keyTpe::valTpe::Nil) = tpe
        
        if(!primativeTypes.exists(_ =:= keyTpe)) {
          c.abort(c.enclosingPosition,
            s"Maps nees to have keys of primative type! Type: $keyTpe")
        }
        val kExpr = c.Expr[String](Ident("kstr"))
        reify{
          startFieldExpr.splice
          writerStack.splice.startObject()
          c.Expr[scala.collection.GenMap[Any,Any]](path).splice.foreach { case (k,v) =>
            val kstr = k.toString
            c.Expr(dumpObject(valTpe,Ident("v"),kExpr)).splice
          }
          writerStack.splice.endObject()
          
        }.tree
        
      // Handle Options
      } else if(tpe <:< typeOf[Option[Any]]) {
        val TypeRef(_,sym:Symbol,pTpe::Nil) = tpe
        reify{
        // I would be happier if I could to c.Expr[Option["real type"]]
        // but this seems to work. I'm not sure if its just for type
        // checking in reify or what...
          PrimativeHelpers.optIdent(c.Expr[Option[Any]](path).splice) match {
            case Some(x) => c.Expr[Unit](dumpObject(pTpe,Ident("x"),name)).splice
            case None    => Unit
          }
        }.tree
      } 
      
      else {  // Complex object
        val TypeRef(_,sym:Symbol,tpeArgs:List[Type]) = tpe
        // get fields
        val fields = getVars(tpe):::getVals(tpe)
        val fieldTrees = fields map { pSym => 
          val pTpe = pSym.typeSignature.substituteTypes(sym.asClass.typeParams,tpeArgs)
          val fieldName = pSym.name.decoded.trim    // Do I need to trim here?
          val fieldPath = Select(path,newTermName(fieldName))
          dumpObject(pTpe,fieldPath,LIT(fieldName))
        }
        
        // Return add all the blocks for each field and pop this obj off the stack
        Block(
        reify{
          startFieldExpr.splice
          writerStack.splice.startObject()
        }.tree::fieldTrees
        ,reify{writerStack.splice.endObject()}.tree)
      }
    } // dumpObject
    
    val code = Block(
      writerStackDef::
      reify{
        writerStack.splice.startObject()
      }.tree::
      dumpObject(weakTypeOf[U],obj.tree,name)::
      reify{
        writerStack.splice.endObject()
      }.tree::Nil,
      c.literalUnit.tree
    )
    //println(s"------------------ Debug: Generated Code ------------------\n $code")
    c.Expr[Unit](code)
  }
  
}
